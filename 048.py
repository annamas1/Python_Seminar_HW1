# Вариант использования функции зип

# Функция zip() создает итератор кортежей, который объединяет элементы каждой из переданных последовательностей *iterables.


# Пример:
# >>> for item in zip([1, 2, 3], ['sugar', 'spice', 'everything nice']):
# ...     print(item)
# то что вернет:
# (1, 'sugar')
# (2, 'spice')
# (3, 'everything nice')



numbers = [2, 3, 4, 5, 6, 7, 5]
diff = list([a*b for a, b in zip(numbers, numbers[:(len(numbers)//2) - 1: -1])])
print(diff)

# zip - создает пару из элементов и затем присваиваем их а и б и умножаем



# Следует учитывать, что итерации, передаваемые в zip(), могут иметь разную длину, иногда намеренно, а иногда из-за ошибки в коде. 
# Python предлагает три разных подхода к решению этой проблемы:

# 1. По умолчанию функция zip() останавливается, когда исчерпывается самая короткая итерация. 
# Она проигнорирует оставшиеся элементы в более длинных итерациях, обрезая результат до длины самой короткой итерации:
# >>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))
# # [(0, 'fee'), (1, 'fi'), (2, 'fo')]

# 2. Функция zip() часто используется в тех случаях, когда предполагается, что итерации имеют одинаковую длину. 
# В таких случаях рекомендуется использовать параметр strict=True (доступен с версии Python 3.10). 
# Вывод будет такой же, как и у обычного zip():
# >>> list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))
# # [('a', 1), ('b', 2), ('c', 3)]
# В отличие от поведения по умолчанию параметр strict=True (доступен с версии Python 3.10), проверяет идентичность длин итераций, вызывая ошибку ValueError, если они не совпадают:
# >>> list(zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True))
# # Traceback (most recent call last):
# #   ...
# # ValueError: zip() argument 2 is longer than argument 1

# 3. Без аргумента strict=True (доступен с версии Python 3.10), любая ошибка, 
# приводящая к итерациям разной длины, будет заглушена, 
# что может проявиться как трудно обнаруживаемая ошибка в другой части программы.
# Более короткие итерации можно дополнить постоянным значением, 
# чтобы все итерации имели одинаковую длину. Это делает itertools.zip_longest().